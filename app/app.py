import signal
import os
import time
from threading import Event
from threading import Thread

from scapy.all import Ether, ICMP, IP, get_if_hwaddr, sendp


from simple_switch.simple_switch_runner import SimpleSwitchDocker
from simple_switch.simple_switch_runner import make_switch
from simple_switch.compile import compile_p4

from p4client.p4grpc import P4RuntimeGRPC
from p4client.fields import MacAddress
from p4client.fields import EgressSpec
from p4client.fields import MulticastGroup

from packettest.packets import make_packet
from packettest.predicates import received_packet
from packettest.predicates import saw_packet_equals_sent
from packettest.test_context import TestContext

from veth_config import config




'''
    Troubleshooting

    invalid netns
    - check namespace doesn't already exist and not bound to a bad pid

    container name in use
    - remove old container (may be exited)

    sysctl: cannot stat /proc/sys/net/ipv6/conf/Ethernet0/disable_ipv6: No such
    file or directory
    - nics stuck in old namespace. delete namespace, delete interfaces

'''


SWITCH_NAME = f'meow'
BRIDGE_NAME = f'simpleswitchbr0'
NETWORK_NAME = f'{SWITCH_NAME}_net'
GRPC_PORT = 9559



def configure_switch(controller, compiled, p4info):
    ''' This function sets up the multicast groups in the switch. It adds all
    the ports as members to a single "multicast" group, and adds a rule whereby
    packets with a layer 2 broadcast address will be submitted to the group.
    This has the effect of pushing the port out on all of the ports in the
    group, and giving layer 2 broadcast behaviour.
    '''
    controller.master_arbitration_update()
    info_data = open(p4info, 'rb').read()
    bin_data = open(compiled, 'rb').read()
    controller._set_info(info_data)
    controller.configure_forwarding_pipeline(bin_data)

    print('Writing broadcast multicast group')
    controller.write_multicast(
        group_id=100,
        replicas=[
            {'egress_port': 0, 'instance': 42},
            {'egress_port': 1, 'instance': 42},
            {'egress_port': 2, 'instance': 42},
            {'egress_port': 3, 'instance': 42},
        ])
    controller.write_table(
        table_name='MyIngress.dmac_table',
        match_fields={
            'hdr.ethernet.dstAddr': MacAddress('ff:ff:ff:ff:ff:ff')
        },
        action_name='MyIngress.multicast_forward',
        action_params={
            'mcast_grp': MulticastGroup(100)
        }
    )




def control_thread(controller, shutdown_event):
    '''The switch is "stateless" and unable to manipulate fields in the 
    dataplane by itself. When a new MAC address is seen, we want to update some
    tables. The source MAC table to pair an address with an ingress port, so
    that we are able to tell if we have seen the address before; and the 
    destination MAC table, which is used to lookup the correct egress port.
    We receive messages in a loop, determine which are the "digest" messages
    describing new MAC addresses which are generated by the control plane, and
    write them to the two tables.
    '''
    while not shutdown_event.is_set():
        msg = controller.get_message(0.1)
        if msg is None:
            continue
        print('received msg')
        if msg.WhichOneof('update') == 'digest':
            print('received digest')
            digests = msg.digest
            for entry in digests.data:
                mac = entry.struct.members[0]
                port = entry.struct.members[1]
                controller.write_table(
                    table_name='MyIngress.smac_table',
                    match_fields={
                        'hdr.ethernet.srcAddr': MacAddress.deserialise(mac.bitstring)
                    },
                    action_name='MyIngress.noop',
                )
                controller.write_table(
                    table_name='MyIngress.dmac_table',
                    match_fields={
                        'hdr.ethernet.dstAddr': MacAddress.deserialise(mac.bitstring)
                    },
                    action_name='MyIngress.mac_forward',
                    action_params={
                        'port': EgressSpec.deserialise(port.bitstring)
                    }
                )
            controller.acknowledge_digest_list(msg.digest.digest_id,
                    msg.digest.list_id)



dir_path = os.path.dirname(os.path.realpath(__file__))
compiled, p4info = compile_p4(dir_path, 'mac_learning.p4')


shutdown_event = Event()
continue_event = Event()

bmv2 = make_switch(config, SWITCH_NAME, NETWORK_NAME, GRPC_PORT)
bmv2.launch()


def wait_start_and_log_stream():
    ''' Start reading the logs and trigger an event when the switch
    application has started the thrift server to test for readiness.
    While not perfect as it isn't testing the gRPC interface, it is a
    good (read: only) proxy for doing so.'''
    for line in bmv2.stream():
        line = line.decode('utf-8').strip()
        if 'Thrift server was started' in line:
            continue_event.set()
        print(line)
logs = Thread(target=wait_start_and_log_stream)
logs.start()
continue_event.wait()


controller = P4RuntimeGRPC(
    host=f'localhost:{GRPC_PORT}',
    device_id=0,
    election_high=0,
    election_low=1
)

caps = controller.capabilities()
print('P4 Runtime API Version: {}'.format(caps))
configure_switch(controller, compiled, p4info)

controller_thread = Thread(target=control_thread, args=[controller, shutdown_event])
controller_thread.start()




context = TestContext()

pkt = Ether(src=get_if_hwaddr('h1eth0'), dst='ff:ff:ff:ff:ff:ff')/IP(
        src='10.0.0.1',
        dst='255.255.255.255')/ICMP()

result1 = context.expect('h2eth0', saw_packet_equals_sent(pkt))
result2 = context.expect('h3eth0', saw_packet_equals_sent(pkt))
result3 = context.expect('h4eth0', saw_packet_equals_sent(pkt))

sendp(pkt, iface='h1eth0')

assert(result1.result() == True)
print("received 1!")
assert(result2.result() == True)
print("received 2!")
assert(result3.result() == True)
print("received 3!")




controller.tear_down_stream()
bmv2.kill()
shutdown_event.set()
controller_thread.join()
logs.join()
